# Base contract for all numeric types (both signed and unsigned)
BaseNumeric[a] = contract(
    eq?[a] = fn(a, a) Bool
    lt?[a] = fn(a, a) Bool
    gt?[a] = fn(a, a) Bool
    lte?[a] = fn(a, a) Bool
    gte?[a] = fn(a, a) Bool
    compare_to[a] = fn(a, a) Int

    add[a] = fn(a, a) a
    sub[a] = fn(a, a) a
    mul[a] = fn(a, a) a
    div[a] = fn(a, a) a
    mod[a] = fn(a, a) a
    pow[a] = fn(a, Int) a

    checked_add[a] = fn(a, a) a
    checked_sub[a] = fn(a, a) a
    checked_mul[a] = fn(a, a) a
    checked_div[a] = fn(a, a) a
    checked_mod[a] = fn(a, a) a
    checked_pow[a] = fn(a, Int) a
)

SignedInt[a] = BaseNumeric[a] | contract(
    abs[a] = fn(a) a
)

UnsignedInt[a] = BaseNumeric[a] | contract(
    leading_zeros[a] = fn(a) Int
)

Numeric[a] = SignedInt[a] | UnsignedInt[a]

sqr[a]: fn(x: Numeric[a]) a { x * x }
abs[a]: fn(x: SignedInt[a]) a { if a < 0 { -x } else { x } }
